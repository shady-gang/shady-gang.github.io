[{"id":0,"href":"/language-extensions/","title":"C/C++ Language Extensions","section":"Index","content":" Using \u0026lt;shady.h\u0026gt; # The \u0026lt;shady.h\u0026gt; header includes definitions for intrinsics and macros that are unique to shaders and not exposed in the C/C++ standard librairies.\nIt is not necessary to include this file in every translation unit, only in the files where you want to use those features, and it is also required to annotate shader module entry points.\nVector types # Vcc makes uses of the existing OpenCL C support in Clang and exposes small vec-types as also found in GLSL. These are typedef\u0026rsquo;d as such:\ntypedef float vec4 __attribute__((ext_vector_type(4))); typedef float vec3 __attribute__((ext_vector_type(3))); typedef float vec2 __attribute__((ext_vector_type(2))); typedef int ivec4 __attribute__((ext_vector_type(4))); typedef int ivec3 __attribute__((ext_vector_type(3))); typedef int ivec2 __attribute__((ext_vector_type(2))); typedef unsigned uvec4 __attribute__((ext_vector_type(4))); typedef unsigned uvec3 __attribute__((ext_vector_type(3))); typedef unsigned uvec2 __attribute__((ext_vector_type(2))); Component swizzling on those types is supported.\nEntry points # Shader entry points need to be annotated with one of:\nfragment_shader vertex_shader compute_shader Also requires setting local_size(x, y, z) Resources / Pipeline layout stuff # Vulkan shaders have to provide some extra information when declaring certain kinds of external variables, that are bound by the host/API side.\nDescriptor set/binding annotations # UBOs, SSBOs and texturing resources need to be annotated with descriptor_binding() and descriptor_set():\ndescriptor_set(0) descriptor_binding(1) uniform int my_funny_buffer[256]; Shader I/O # Similar to recent versions of GLSL, input and output variables need to provide a location(N):\nlocation(0) input vec2 texCoord; location(0) output vec4 pixelColor; See the following list of address soaces\nAddress spaces # LLVM and Clang already support address spaces using the __attribute__((address_space(N))) syntax. Shady merely reserves some numbers for custom address spaces, and tries to line up with other targets where possible.\nVcc keyword SPIR-V Storage class Purpose input Input Pipeline-specific inputs output Output Pipeline-specific outputs uniform_constant UniformConstant Most opaque descriptor-bound resources (samplers, textures, \u0026hellip;) uniform_block Uniform Vulkan UBOs shared Workgroup Workgroup-visible local memory private Private / Function Invocation private memory global PhysicalStorageBuffer Main memory (VRAM and mapped host memory) While Shady supports generic pointers, only private, shared and global will be able to work with them. There are many more address spaces found in SPIR-V that have usage restrictions that make them pointless to support in generic pointers, and therefore those need to be explicitly specified.\nThis is also true for global variables: while you can get a generic pointer to them (just cast it!), the variables do need to be allocated somewhere !\nTexturing # "},{"id":1,"href":"/how/","title":"How this works","section":"Index","content":" What is Shady # Vcc is little more than a front-end for Shady, a compiler and IR resulting from years of research and development at Saarland University. Shady was initially started to rationalize our GPU backends by supporting Vulkan in AnyDSL\nAs a language, it\u0026rsquo;s close to SPIR-V and LLVM but we have our own twist on a few things, in particular control-flow. Shady\u0026rsquo;s representation gives it distinct advantages when emulating constructs not found in SPIR-V. It is by necessity strongly aligned with SPIR-V and uses parts of the format verbatim in the IR, such as the builtins.\nYou can think of Shady as implementing a futuristic dialect of SPIR-V that corresponds to our wishlist of features. We are currently working towards publishing papers on the internals of shady and we will be updating this website with more detail once we do.\nShady is free software and we\u0026rsquo;d love to have other front-ends use it ! This is an explicit goal of the project.\nRelationship to Clang and LLVM # Vcc is a wrapper for the clang driver and directs it to emit the LLVM IR for your source files. LLVM is not involved in any optimizations on the code, instead Shady parses the LLVM IR and runs its set of optimization and legalization passes to turn the IR into something that can run on Vulkan. Finally, Shady emits SPIR-V code that your application can then use.\nVcc does not use a fork of LLVM nor Clang. It needs to link against LLVM to use its bitcode parser and C API, but any recent version of LLVM should work. Shady supports both typed and untyped pointers so a large range of LLVM versions should work with it.\nExposing SPIR-V/Vulkan as C/C++ language extensions # Since we are not modifying Clang, we had to find a way to add our own intrinsics to expose features not present in standard C/C++, such as fixed-function texturing support. This is done through the general-purpose __attribute__((annotate(\u0026quot;\u0026quot;))) annotations, which are thankfully retained in the IR. Shady comes with a \u0026lt;shady.h\u0026gt; header that you can simply include in your application to use the extra features. You can look at the Vcc tests and samples for guidance on how to use these.\nSome features are currently not exposed, but that doesn\u0026rsquo;t mean that Vcc/Shady cannot easily support them. As we are developing this we are constantly exposing new extensions, sometimes it is just a matter of adding appropriate intrinsics. Feel free to raise issues on GitHub if there is something you\u0026rsquo;d like to see.\n"},{"id":2,"href":"/use/","title":"Using Vcc","section":"Index","content":" Getting a copy of Vcc # There currently are no release builds available for Vcc, however it can be compiled as part of Shady which is freely available on GitHub. The following dependencies are required:\nA C11 compliant compiler CMake 3.13 or later json-c SPIRV-Headers Vulkan-Headers are optional but are used to build some components of shady such as tests A copy of LLVM that includes the CMakeConfig.cmake files, so that Vcc can link against it Multiple LLVM versions are supported because we use LLVM-C, which has a more stable interface. Versions 14 to 17 have been tested so far. Additionally, a copy of clang on your path is required at runtime for vcc to operate. This copy may be a different version than the LLVM you linked Vcc against, however might cause issues due to how the LLVM IR evolves over time.\nUsing Vcc # Vcc is used much like GCC or Clang is. In fact, most arguments are just forwarded to Clang! Using vcc --help one can a list of vcc specific arguments and flags. Vcc can produce SPIR-V binary files, and also has experimental support for GLSL and ISPC output. These SPIR-V files can then be ingested by your application as normal.\nLanguage extensions and \u0026lt;shady.h\u0026gt; # See C/C++ Language Extensions.\nRequired Vulkan version and capabilities # Vcc currently requires Vulkan 1.1 and support for VK_KHR_buffer_device_address. It also currently requires support for Int8, Int16 and Int64 and subgroup ballots. These features are ubiquitous on desktop-class hardware and even many phones nowadays.\nSome features are or will be made optional, with some corresponding degradations on the capabilities of the compiler. We are still working on organizing the compiler flags and we will be writing up a more comprehensive support matrix later.\nSupported drivers # The following drivers and hardware have been tested with Shady:\nName Result Notes radv (AMD Mesa) OK Main development target amdvlk (AMD open-source) OK AMD proprietary (Windows) OK NVidia proprietary (Windows) OK Has/had some small driver issues, with workarounds. nvk Mixed, needs more testing Subgroup support for Maxwell is still WIP. anv (Intel Mesa) OK Intel Arc proprietary (Windows) OK Older drivers lack Int64, make sure to update MoltenVK Mixed SPIRV-Cross does not like Shady\u0026rsquo;s codegen. Patches WIP. Imagination proprietary (BXT series) Needs more testing Tested on VisionFive II, small examples work llvmpipe (Mesa software rendering) KO Lacks extension support, has weird SIMT behavior SwiftShader (Google software rendering) KO Lacks extension support, needs more testing "},{"id":3,"href":"/why/","title":"Why ?","section":"Index","content":"This is a lot of effort. Why ?\nDissatisfaction with \u0026ldquo;Legacy\u0026rdquo; Shading Languages # Back in the early 2000s a significant revolution happened in the world of realtime computer graphics: we moved from \u0026ldquo;dumb\u0026rdquo; graphics accelerator that had only a fixed set of functionality (texturing slots, blended vertex colors, hardware T\u0026amp;L \u0026hellip; ) to increasingly programmable hardware. This hardware transition was accompanied by an API transition, de-emphasizing the classic OpenGL state machine in favour of then-new high-level shading languages: GLSL and HLSL.\nSince then, comparatively little has happened to the shading language ecosystem for graphics APIs. The aforementioned pair is still relevant for Vulkan and DirectX 12, even though the rest of the API surface has been dramatically modernized. Worse still, their once bleeding-edge capabilities have since then dulled in relevance, and the approach of having dedicated languages with custom syntax directly conflicts with the goals of GPU offloading and heterogenous compute.\nThe Compute and Graphics Schism # Broadly speaking, there are two kinds of GPU APIs: compute and graphics. CUDA, ROCm and OpenCL are filed as the former, while Vulkan, DirectX and OpenGL would be the latter. On the surface it would seem that graphics APIs and compute APIs overlap - both let you program the GPU, and in fact modern graphics APIs offer \u0026ldquo;compute shaders\u0026rdquo;.\nBut these compute shaders are not the same as the compute kernels found in dedicated GPGPU APIs, and severely lag behind in terms of features. Modern GPGPUs APIs work towards making GPU programming as close to general programming as possible - implementing complete C and C++ compilers for GPUs that follow normal syntax.\nWorking Towards Single-Source GPU programming # Vulkan is arguably not so far behind in capabilities compared to some compute APIs like OpenCL. There are already efforts to layer OpenCL on top of Vulkan and Vcc/Shady are comparable to those, and in fact ahead when it comes to supporting function pointers, since OpenCL does not have them as a standard feature. Generic pointer support in OpenCL is also spotty and optional.\nWhat Vcc shares with OpenCL C, CUDA and even Metal to an extent, is this goal to align host and device code and even unify it. While Vcc is not a true \u0026ldquo;single source\u0026rdquo; compiler in the sense that one file can produce both host and device code, it is not only viable, but the intended use-case to have projects compiling the same code twice for host and device without modifications 1.\nThe Maintenance Issue # Due to their baggage as C-like languages that were neither proper subsets nor super-sets of C or C++, GLSL and HLSL have had difficulties to adapt to the evolving API landscape. The support for modern features like VK_KHR_buffer_device_address is awkward 2, and there is no shortage of bugs and issues plaguing DXC. The maintainers of DXC in fact intend to move to a mainline version of LLVM in the future, and we think this is the right approach, if perhaps not going far enough.\nIn truth, we see little future to bespoke C-like shading languages for GPU programming. A standard Clang toolchain with minor extensions has been shown to be a viable approach for many years in the compute world and on Apple devices, and the benefits both for the users, but also for maintaining the toolchain in the long run, are too large to ignore.\nBootstrapping the Future # We have been privately arguing for evolving towards a simpler, more expressive future for not only high-level shader code but also the underlying SPIR-V IR capabilities, for giving it access to richer features that align with the programming model of the host.\nThere is a chicken and egg problem here however, and that is that IHVs are less inclined to spend engineering resources supporting a feature that may require significant internal compiler changes, meanwhile you cannot simply bolt a SPIR-V back-end to LLVM and have that work with Vulkan, due to all the constraints imposed by Vulkan.\nWe hope to contribute to solving this chicken and egg problem with Shady by removing the bigger limitations that we find stand in the way. Vcc is the result of this work.\nMaking Vcc a \u0026ldquo;true\u0026rdquo; single-source framework would involve working with Clang\u0026rsquo;s existing offloading support and is considered out of scope for now.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe believe this is due to their long legacy, where these languages had no pointers in the syntax at all. We get to simply expose the newfound support for pointers in shaders using standard pointer syntax!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"}]